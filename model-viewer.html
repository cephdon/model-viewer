<link rel="import" href="../paper-styles/paper-styles.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-toolbar/paper-toolbar.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">

<link rel="import" href="../paper-input/paper-input.html">

<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../iron-collapse/iron-collapse.html">

<script src="../three.js/build/three.min.js"></script>

<script src="../three.js/examples/js/Detector.js"></script>
<script src="../three.js/examples/js/loaders/STLLoader.js"></script>
<script src="../bytebuffer/dist/ByteBufferAB.js"></script>
<script src="../protobuf/dist/ProtoBuf.js"></script>
<script src="../jszip/dist/jszip.min.js"></script>
<script src="amfloader.js"></script>

<script src="model-viewer-OrbitControls.js"></script>
<script src="utility.js"></script>

<dom-module id="model-viewer">
  <style>
    :host {
    }

    .placeholderimg {
      width: 100%;
      height: auto;
    }

    .viewercontainer {
      position: relative;
      margin: 0 5%;
      padding: 0;
    }

    .loadingspinner {
      position: absolute;
      top: 50%;
      right: 50%;
      z-index: 10;
    }

    .buttonloadmodel {
      position: absolute;
      right: 10px;
      top: 10px;
      background: blue;
      color: white;
      z-index: 10;
    }

    .viewertoolbarcontainer {
      position: relative;
      margin-left: 0.5em;
    }

    .viewertoolbar {
      --paper-toolbar-background: white;
    }

    .viewertoolscontainer {
      position: relative;
      margin: 0 5%;
      padding: 0;
    }

    .viewertoolbarbuttons {
      background: blue;
      color: white;
    }

    .viewertoolbartoggles {
    }

    paper-button[disabled] {
      background-color: gray;
    }

    .viewertoolbarsectionlabels {
      color: black;
      text-transform: uppercase;
      display: inline-block;
      margin: 0;
    }

    .viewertoolbarlabels {
      color: black;
      text-transform: uppercase;
      margin: 0 0.5em;
    }

    .btnexportlabel {
      color: white;
      text-transform: uppercase;
      font-weight: bold;
      display: inline;
    }

    .numfloat {
      width: 3em;
    }

    .scaleinputs {
      margin: 0 1em;
    }

  </style>

  <template>
      <div class="viewercontainer" on-scenerendered="scenerendered" on-modelloaded="modelloaded">
        <img class="placeholderimg" src="{{previewimg}}"/>
        <paper-button class="buttonloadmodel" on-click="onloadmodel" raised>
          <iron-icon icon="icons:3d-rotation"></iron-icon>
        </paper-button class="viewertoolbar">
        <paper-spinner class="loadingspinner" inactive></paper-spinner>
      </div>

      <iron-collapse id="expandcontrols" class="controlscollapse">
        <div class="viewertoolscontainer">
          <template is="dom-if" if="{{selectedobject}}">
            <div class="viewertoolbarcontainer horizontal layout wrap flex">
              <paper-item>{{selectedobject.mesh.name}}</paper-item>
              <span class="flex"></span>
              <paper-button class="viewertoolbarbuttons" on-click="exportstl" raised>
                <iron-icon icon="icons:launch"></iron-icon>
                <paper-item class="btnexportlabel">STL</paper-item>
              </paper-button>
            </div>
          </template>
          <template is="dom-if" if="{{!selectedobject}}">
            <paper-item>No model selected</paper-item>
          </template>

          <div>
            <paper-icon-button id="expandmodelcontrolstoggle" icon="icons:expand-more" on-click="expandmodelcontrols"></paper-icon-button>
            <paper-item class="viewertoolbarsectionlabels">Model Options</paper-item>
            <iron-collapse id="expandmodelcontrols" class="controlscollapse">
              <div class="viewertoolbarcontainer horizontal layout wrap flex">
                <paper-item>
                  <paper-toggle-button class="viewertoolbartoggles" on-change="togglewireframe" checked={{enablewireframe}} disabled></paper-toggle-button>
                  <span class="viewertoolbarlabels">Wireframe</span>
                </paper-item>
                <paper-item>
                  <paper-toggle-button class="viewertoolbartoggles" on-change="toggleboundingbox" checked={{enableboundingbox}} disabled></paper-toggle-button>
                  <span class="viewertoolbarlabels">Bounding Box</span>
                </paper-item>
              </div>
              <div class="viewertoolbarcontainer horizontal layout wrap flex">
                <paper-input name="Scale X" label="Scale X" class="scaleinputs numfloat" type="number" value="{{scalex}}" on-change="scalechange"></paper-input>
                <paper-input name="Scale Y" label="Scale Y" class="scaleinputs numfloat" type="number" value="{{scaley}}" on-change="scalechange"></paper-input>
                <paper-input name="Scale Z" label="Scale Z" class="scaleinputs numfloat" type="number" value="{{scalez}}" on-change="scalechange"></paper-input>
                <paper-item>
                  <paper-toggle-button class="viewertoolbartoggles" on-change="scalechange" checked={{scaleconstrain}} on-change="scalechange" disabled></paper-toggle-button>
                  <span class="viewertoolbarlabels">Constrain Scale</span>
                </paper-item>
              </div>

              <div class="viewertoolbarcontainer horizontal layout wrap flex">
                <paper-input label="Rotate X" class="scaleinputs numfloat" type="number" value="{{rotatex}}" on-change="rotatechange"></paper-input>
                <paper-input label="Rotate Y" class="scaleinputs numfloat" type="number" value="{{rotatey}}" on-change="rotatechange"></paper-input>
                <paper-input label="Rotate Z" class="scaleinputs numfloat" type="number" value="{{rotatez}}" on-change="rotatechange"></paper-input>
              </div>
            </iron-collapse>
          </div>

          <div>
            <paper-icon-button id="expandextrastoggle" icon="icons:expand-more" on-click="expandextras"></paper-icon-button>
            <paper-item class="viewertoolbarsectionlabels">Extras</paper-item>
            <iron-collapse id="expandextras" class="controlscollapse">
              <div class="viewertoolbarcontainer horizontal layout wrap flex">
                <paper-button class="viewertoolbarbuttons button-scene-snapshot" on-click="capturescene" raised>
                  <iron-icon icon="icons:camera-enhance"></iron-icon>
                </paper-button>
              </div>
            </iron-collapse>
          </div>
        </div>
      </iron-collapse>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'model-viewer',

    ready: function() {
    },

    attached: function() {
    },

    toggleExpandIcon: function(control, toggleicon) {
      var icon = "icons:expand-less";

      control.toggle();

      if(toggleicon.getAttribute('icon') === "icons:expand-less") {
        icon = "icons:expand-more";
      }

      toggleicon.setAttribute('icon', icon);
    },

    expandmodelcontrols: function(e) {
      this.toggleExpandIcon(this.$.expandmodelcontrols, this.$.expandmodelcontrolstoggle);
    },

    expandextras: function(e) {
      this.toggleExpandIcon(this.$.expandextras, this.$.expandextrastoggle);
    },

    onloadmodel: function() {
      var renderElement = this.getElementsByClassName("viewercontainer")[0];

      if(!Detector.webgl) {
        var glerror = Detector.getWebGLErrorMessage();
        glerror.style.padding = "";
        glerror.style.margin = "";
        glerror.style.width = "100%";

        renderElement.innerHTML = '';
        renderElement.appendChild(glerror);

        return;
      }

      var spinner = this.getElementsByClassName("loadingspinner")[0];

      this.renderElement = renderElement;
      this.spinner = spinner;

      // Keep square by using width twice
      var viewerHeight = renderElement.offsetWidth;
      var viewerWidth = renderElement.offsetWidth;
      var aspectRatio = viewerWidth / viewerHeight;

      this.viewerHeight = viewerHeight;
      this.viewerWidth = viewerWidth;
      this.aspectRatio = aspectRatio;

      var scene = new THREE.Scene();
      this.scene = scene;

      var camera = new THREE.PerspectiveCamera(60, this.aspectRatio, 0.1, 1000);
      this.camera = camera;

      scene.fog = new THREE.Fog(0xeeeeee, 1, 500);

      var lights = {"camera": null,
                    "ambient": null};

      this.lights = lights;

      lights.camera = new THREE.DirectionalLight(this.lightcolor, this.lightintensity);
      lights.ambient = new THREE.AmbientLight(this.lightambientcolor);

      camera.add(lights.camera);
      camera.name = "Camera";
      scene.add(camera);

      lights.ambient.name = "Ambient Light";
      scene.add(lights.ambient);

      // Z is *up* for 3D printing! :)
      camera.up = new THREE.Vector3(0, 0, 1);

      camera.lookAt(new THREE.Vector3(0, 0, 0));

      camera.updateProjectionMatrix();

      var renderer = new THREE.WebGLRenderer({antialias: true});
      this.renderer = renderer;

      var render = function() {
        this.renderer.render(this.scene, this.camera);
      }

      renderer.setSize(viewerWidth, viewerHeight);

      this.spinner.setAttribute('active', true);

      if (this.loadmethod === "stl" || this.loadmethod === "json" || this.loadmethod === "amf") {
        if(this.loadmethod === "stl") {
          var loader = new THREE.STLLoader();
        } else if(this.loadmethod === "json") {
          var loader = new THREE.JSONLoader();
        } else if(this.loadmethod === "amf") {
          var loader = new AMFLoader();
        }

        var modelloadeddispatch = function(geometry, materials) {
          this.renderElement.dispatchEvent(new CustomEvent('modelloaded', {'detail': { 'geometry': geometry, 'materials': materials, 'name': this.modelname}}));
        };

        loader.load(this.model, modelloadeddispatch.bind(this));
      } else if (this.loadmethod === "protobuf") {
        var xhr = new XMLHttpRequest();
        xhr.renderElement = this.renderElement;

        xhr.open("GET", this.proto, true);

        xhr.onload = function(e) {
          console.log("Loaded proto buffer definition.");

          var ProtoBuf = dcodeIO.ProtoBuf;
          var MeshMsg = ProtoBuf.loadJson(this.response).build("meshthreejs").MeshThreeJS;

          var pb_xhr = ProtoBuf.Util.XHR();

          pb_xhr.open("GET", this.modelviewer.model, true);

          pb_xhr.responseType = "arraybuffer";

          pb_xhr.onload = function(e) {
            console.log("Loaded protobuffer.");

            var msg = this.MeshMsg.decode(this.response);

            var loader = new THREE.JSONLoader().parse(msg);
            var modelLoadedEvent = new CustomEvent('modelloaded', {'detail': {'name': this.modelname, 'materials': loader.materials, 'geometry': loader.geometry}});
            this.renderElement.dispatchEvent(modelLoadedEvent);
          }

          pb_xhr.MeshMsg = MeshMsg;
          pb_xhr.renderElement = this.renderElement;
          pb_xhr.modelname = this.modelname
          pb_xhr.send();

        }

        xhr.modelviewer = {model: this.model};
        xhr.send();

      } else {
        console.log("Element has weird loadmethod: " + this.loadmethod);
      }

      renderer.domElement.addEventListener("clickselect", this.onclickselect.bind(this));

      var controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.damping = 0.2;
      controls.addEventListener('change', render.bind(this));
      this.controls = controls;

      this.selectionmaterial = new THREE.MeshPhongMaterial({color: 0x00dd11, shading: THREE.FlatShading});

      this.selectionmaterial.transparent = true;
      this.selectionmaterial.opacity = 0.95;

      window.addEventListener("resize", this.viewerresized.bind(this));
    },

    modelloaded: function(e) {
      console.log("Loaded model event");

      var renderer = this.renderer;
      var scene = this.scene;
      var camera = this.camera;
      var geometries = [];
      var materials = [];
      var defaultmaterial = new THREE.MeshPhongMaterial({ color: this.modelcolor, shading: THREE.FlatShading });

      var geometry = e.detail.geometry;

      renderer.setClearColor(this.backgroundcolor);

      if(e.detail.materials === undefined) {
        materials.push(defaultmaterial);
        materials.push(new THREE.MeshPhongMaterial({ color: 0x24c92a, shading: THREE.FlatShading }));
      } else if(e.detail.materials instanceof Array) {
        materials = e.detail.materials;
      } else {
        materials.push(e.detail.materials);
      }

      // Needs to handle multiple geometry loads - specifically for AMF
      if(geometry instanceof Array) {
        for(var i = 0; i < geometry.length; i++) {
            geometries.push(geometry[i]);
        }
      } else {
        geometries.push(geometry);
      }

      // Convert any THREE.Geometry objects to THREE.BufferGeometry
      for(var i = 0; i < geometries.length; i++) {
        if(geometries[i] instanceof THREE.Geometry) {
          var bgeometry = new THREE.BufferGeometry();
          bgeometry.fromGeometry(geometries[i]);
          geometries[i].dispose();
          geometries[i] = bgeometry;
        }
      }

      // Ensure minimum values
      var min = {x: -1, y: -1, z: -1};
      var max = {x: 1, y: 1, z: 1};

      for(var i = 0; i < geometries.length; i++) {
        var currmaterial = materials[0];
        var sceneobject = { mesh: null, boundingbox: null,
                            originalmaterial: null,
                            wireframe: null, enablewireframe: false,
                            boxhelper: null, enableboxhelper: false,
                            selected: false,
                            rotation: {x: 0, y: 0, z: 0},
                            scale: {x: 1.0, y: 1.0, z: 1.0, constrain: true}};

        if(i < materials.length && materials[i] !== null) {
          currmaterial = materials[i];
        } else {
          currmaterial = defaultmaterial;
        }

        sceneobject.originalmaterial = currmaterial;

        var renderobject = new THREE.Mesh(geometries[i], currmaterial);
        renderobject.name = geometries[i].name || this.modelname;

        scene.add(renderobject);

        sceneobject.mesh = renderobject;

        var renderobjectwireframe = new THREE.WireframeHelper(renderobject, 0xffffff);
        renderobjectwireframe.name = "wireframe-" + renderobject.uuid;

        scene.add(renderobjectwireframe);

        renderobjectwireframe.visible = this.enablewireframe;
        sceneobject.enablewireframe = this.enablewireframe;
        sceneobject.wireframe = renderobjectwireframe;

        var boundingbox = new THREE.Box3().setFromObject(renderobject);

        sceneobject.boundingbox = boundingbox;

        if(boundingbox.min.z < 0) {
          renderobject.translateZ(-boundingbox.min.z);
          boundingbox.setFromObject(renderobject);
        }

        max.x = Math.max(boundingbox.max.x, max.x);
        min.x = Math.min(boundingbox.min.x, min.x);
        max.y = Math.max(boundingbox.max.y, max.y);
        min.y = Math.min(boundingbox.min.y, min.y);
        max.z = Math.max(boundingbox.max.z, max.z);
        min.z = Math.min(boundingbox.min.z, min.z);

        var renderobjectboxhelper = new THREE.BoxHelper(renderobject);
        renderobjectboxhelper.name = "boxhelper-" + renderobject.uuid;
        renderobjectboxhelper.material.color.set(this.wireframecolor);

        scene.add(renderobjectboxhelper);
        renderobjectboxhelper.visible = this.enableboundingbox;
        sceneobject.enableboxhelper = this.enableboundingbox;
        sceneobject.boxhelper = renderobjectboxhelper;

        this.sceneobjects.push(sceneobject);
      }

      var objectfloorgrid = new THREE.GridHelper(Math.round((Math.max(max.x, max.y)/10)+1)*10,
                                                 10.0);

      objectfloorgrid.name = "GridHelper";

      objectfloorgrid.setColors(this.gridcolor, this.gridcolor);

      // Turn floor to match Z-up orientation
      objectfloorgrid.rotation.x = 90*(Math.PI/180);

      scene.add(objectfloorgrid);

      var objectcenter = new THREE.Vector3(0,0,0);

      camera.position.z = max.z;
      camera.position.y = max.z*-2;
      camera.position.x = 0;

      camera.lookAt(objectcenter);

      this.controls.target = objectcenter;

      camera.updateProjectionMatrix();

      renderer.render(scene, camera);

      this.renderElement.dispatchEvent(new CustomEvent('scenerendered', {'detail': {'renderElement': this.renderer.domElement}}));
    },

    disablebuttons: function() {
      var toolbarbuttons = this.getElementsByClassName('viewertoolbarbuttons');
      var toolbartoggles = this.getElementsByClassName('viewertoolbartoggles');

      for(var i = 0; i < toolbarbuttons.length; i++) {
        if(toolbarbuttons[i].classList.contains("button-scene-snapshot")) {

          continue;
        }
        toolbarbuttons[i].setAttribute('disabled', true);
      }

      for(var i = 0; i < toolbartoggles.length; i++) {
        toolbartoggles[i].setAttribute('disabled', true);
      }
    },

    enablebuttons: function() {
      var toolbarbuttons = this.getElementsByClassName('viewertoolbarbuttons');
      var toolbartoggles = this.getElementsByClassName('viewertoolbartoggles');

      for(var i = 0; i < toolbarbuttons.length; i++) {
        toolbarbuttons[i].removeAttribute('disabled');
      }

      for(var i = 0; i < toolbartoggles.length; i++) {
        toolbartoggles[i].removeAttribute('disabled');
      }
    },

    scenerendered: function(e) {
      console.log("Scene rendered!");

      this.spinner.removeAttribute('active');
      this.renderElement.innerHTML = "";
      this.modelscene = e.detail;

      this.renderElement.innerHTML = '';
      this.renderElement.appendChild(e.detail.renderElement);

      this.$.expandcontrols.toggle();
    },

    viewerresized: function(e) {
      var renderwidth = this.renderElement.offsetWidth;
      var renderheight = this.renderElement.offsetWidth;

      // Keep squared
      this.renderwidth = renderwidth;
      this.renderheight = renderheight;

      this.aspectratio = renderwidth / renderheight;

      if(this.renderer) {
        this.renderer.setSize(renderwidth, renderheight);
      }
    },

    capturescene: function(e) {
      this.renderer.render(this.scene, this.camera);
      this.renderer.capture = this.renderer.domElement.toDataURL();

      var downloadlink = document.createElement('a');
      downloadlink.download = this.modelname + ".png";
      downloadlink.href = this.renderer.capture;
      document.body.appendChild(downloadlink);
      downloadlink.click();
      document.body.removeChild(a);
    },

    togglewireframe: function (e) {
      if(this.selectedobject === null) {
        return;
      }

      this.selectedobject.wireframe.visible = this.enablewireframe;
      this.selectedobject.enablewireframe = this.enablewireframe;

      this.renderer.render(this.scene, this.camera);
    },

    toggleboundingbox: function (e) {
      if(this.selectedobject === null) {
        return;
      }

      var boxhelpername = "boxhelper-" + this.selectedobject;

      this.selectedobject.boxhelper.visible = this.enableboundingbox;
      this.selectedobject.enableboxhelper = this.enableboundingbox;

      this.renderer.render(this.scene, this.camera);
    },

    exportstl: function (e) {
      if(this.selectedobject === null) {
        alert("Select an object");
        return;
      }

      var mesh = this.selectedobject.mesh;

      var meshgeometry = mesh.geometry.getAttribute('position').clone();
      var vertices = null;

      // Convert indexed BufferGeometry to non-indexed to apply matrix, easier index, etc
      if(mesh.geometry.getAttribute('index') === undefined) {
        console.log("Non-indexed geometry");
        vertices = meshgeometry.array;
      } else {
        console.log("Indexed geometry");
        var faces = mesh.geometry.getAttribute('index').array;
        var vertarray = new Float32Array(faces);

        for(var i = 0; i < faces.length; i++) {
          vertarray[i] = meshgeometry.array[faces[i]];
        }

        vertices = vertarray;
      }

      mesh.matrix.applyToVector3Array(vertices);

      var sizeofstl = 80+4+((vertices.length/9)*50);
      var faces = vertices.length/9;

      console.log("Exporting STL");
      console.log("  Faces: " + faces + ", Vertices: " + vertices.length);
      console.log("  Size of STL: " + sizeofstl);

      var stlbuffer = new dcodeIO.ByteBuffer(capacity=sizeofstl, littleEndian=true);
      var headerstring = "TamarinTech Model-Viewer STL Exporter: " + mesh.name;

      stlbuffer.writeUTF8String(headerstring.substring(0, 80));
      stlbuffer.skip(80 - headerstring.length);

      stlbuffer.writeUint32(vertices.length/9);

      for(var vi = 0; vi < vertices.length; ) {
        stlbuffer.writeFloat32(0); // Normal a
        stlbuffer.writeFloat32(0); // Normal b
        stlbuffer.writeFloat32(0); // Normal c

        for(var facei = 0; facei < 9; facei++) {
          stlbuffer.writeFloat32(vertices[vi++]);
        }

        stlbuffer.writeUint16(0); // Attribute
      }

      stlbuffer.flip();

      var a = document.createElement('a');
      var stlblob = new Blob([stlbuffer.toArrayBuffer()], {type: "octet/stream"});
      a.href = window.URL.createObjectURL(stlblob);
      a.download = mesh.name + ".stl";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    },

    scalechange: function (e) {
      if(this.selectedobject === null) {
        return;
      }

      var obj = this.selectedobject;

      obj.scale.constrain = this.scaleconstrain;

      if(obj.scale.constrain) {
        if(e.target.name === "Scale X") {
          this.scaley = this.scalex;
          this.scalez = this.scalex;
        } else if(e.target.name === "Scale Y") {
          this.scalex = this.scaley;
          this.scalez = this.scaley;
        } else if(e.target.name === "Scale Z") {
          this.scalex = this.scalez;
          this.scaley = this.scalez;
        } else {
          // The constraint button was toggled
          var scale = Math.max(this.scalex, this.scaley, this.scalez);
          this.scalex = scale;
          this.scaley = scale;
          this.scalez = scale;
        }
      }

      if(this.scalex <= 0) {
        this.scalex = 0.1;
      }

      if(this.scaley <= 0) {
        this.scaley = 0.1;
      }

      if(this.scalez <= 0) {
        this.scalez = 0.1;
      }

      obj.scale.x = this.scalex;
      obj.scale.y = this.scaley;
      obj.scale.z = this.scalez;

      obj.mesh.scale.set(obj.scale.x, obj.scale.y, obj.scale.z);

      obj.boundingbox.setFromObject(obj.mesh);

      // Keep object above floor
      if(obj.boundingbox.min.z < 0) {
        obj.mesh.translateZ(-obj.boundingbox.min.z);
      }

      obj.boundingbox.setFromObject(obj.mesh);
      obj.boxhelper.update(obj.mesh);

      this.renderer.render(this.scene, this.camera);
    },

    rotatechange: function (e) {
      if(this.selectedobject === null) {
        return;
      }

      var obj = this.selectedobject;

      obj.mesh.rotation.set(0, 0, 0, 0);

      obj.rotation.x = this.rotatex;
      obj.rotation.y = this.rotatey;
      obj.rotation.z = this.rotatez;

      obj.mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), this.rotatex*(Math.PI/180));
      obj.mesh.rotateOnAxis(new THREE.Vector3(0, 1, 0), this.rotatey*(Math.PI/180));
      obj.mesh.rotateOnAxis(new THREE.Vector3(0, 0, 1), this.rotatez*(Math.PI/180));

      this.renderer.render(this.scene, this.camera);
    },

    onclickselect: function (e) {
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();

      var canvaswidth = this.renderer.domElement.width;
      var canvasheight = this.renderer.domElement.height;

      mouse.x = (e.detail.x / canvaswidth) * 2 - 1;
      mouse.y = - (e.detail.y / canvasheight) * 2 + 1;

      var selectableobjects = [];

      for(var i = 0; i < this.sceneobjects.length; i++) {
        if(this.sceneobjects[i].mesh instanceof THREE.Mesh) {
          selectableobjects.push(this.sceneobjects[i].mesh);
        }
      }

      if(this.selectedobject) {
        for(var i = 0; i < this.sceneobjects.length; i++) {
          if(this.sceneobjects[i] === this.selectedobject) {
            this.sceneobjects[i].mesh.material = this.sceneobjects[i].originalmaterial;
          }
        }
      }

      raycaster.setFromCamera(mouse, this.camera);

      var intersections = raycaster.intersectObjects(selectableobjects, true);

      if(intersections.length) {
        var selectedobjectuuid = intersections[0].object.uuid;
        this.selectedface = intersections[0];

        for(var i = 0; i < this.sceneobjects.length; i++) {
          if(this.sceneobjects[i].mesh.uuid === selectedobjectuuid) {
            this.selectedobject = this.sceneobjects[i];
            this.enablewireframe = this.selectedobject.enablewireframe;
            this.enableboundingbox = this.selectedobject.enableboxhelper;

            this.rotatex = this.selectedobject.rotation.x;
            this.rotatey = this.selectedobject.rotation.y;
            this.rotatez = this.selectedobject.rotation.z;

            this.scalex = this.selectedobject.scale.x;
            this.scaley = this.selectedobject.scale.y;
            this.scalez = this.selectedobject.scale.z;

            this.scaleconstrain = this.selectedobject.scale.constrain;

            this.sceneobjects[i].mesh.material = this.selectionmaterial;
            this.enablebuttons();
            break;
          }
        }
      } else {
        if(this.selectedobject) {
          this.selectedobject.mesh.material = this.selectedobject.originalmaterial;
        }

        this.disablebuttons();
        this.rotatex = 0;
        this.rotatey = 0;
        this.rotatez = 0;

        this.scalex = 0;
        this.scaley = 0;
        this.scalez = 0;

        this.scaleconstrain = false;
        this.selectedobject = null;
        this.selectedface = null;
      }

      this.renderer.render(this.scene, this.camera);

    },

    properties: {
      model: {
        type: String
      },
      modelname: {
        type: String
      },
      loadmethod: {
        type: String
      },
      proto: {
        type: String
      },
      previewimg: {
        type: String
      },

      backgroundcolor: {
        type: Number,
        value: 0x0
      },
      gridcolor: {
        type: Number,
        value: 0xffffff
      },
      modelcolor: {
        type: Number,
        value: 0xaaaaff
      },
      wireframecolor: {
        type: Number,
        value: 0xaaaaff
      },
      lightambientcolor: {
        type: Number,
        value: 0x777777
      },
      lightcolor: {
        type: Number,
        value: 0xffffff
      },
      lightintensity: {
        type: Number,
        value: 0.6
      },

      enablewireframe: {
        type: Boolean,
        value: false
      },
      enableboundingbox: {
        type: Boolean,
        value: false
      },

      rotatex: {
        type: Number,
        value: 0
      },
      rotatey: {
        type: Number,
        value: 0
      },
      rotatez: {
        type: Number,
        value: 0
      },

      scalex: {
        type: Number,
        value: 1.0
      },
      scaley: {
        type: Number,
        value: 1.0
      },
      scalez: {
        type: Number,
        value: 1.0
      },

      scaleconstrain: {
        type: Boolean,
        value: false
      },

      selectedobject: {
        type: Object,
        value: null
      },
      selectedface: {
        type: Object,
        value: null
      },
      sceneobjects: {
        type: Array,
        value: []
      }

    }
  });
</script>
